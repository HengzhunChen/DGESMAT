function HamKS = CalculatePseudoPotential(HamKS)
% HAMILTONIANKS/CALCULATEPSEUDOPOTENTIAL calculates pseudo potential.
%
%    HamKS = CalculatePseudoPotential(HamKS) computes 
%    (1) number of occupied states and stores as HamKS.numOccupiedState;
%    (2) pseudo potential for each atom in HamKS.atomList and stores as a
%        struct list HamKS.pseudoList whose member include pseudoCharge, 
%        vLocalSR and vnlList;
%    (3) local potential generated by all atoms. Computes short range 
%        local potential and Gaussian compensation charge, stores as 
%        HamKS.vLocalSR and HamKS.pseudoCharge respectively;
%    (4) other energies and forces, including self energy, short range 
%        ionic energy, van der Waals energy and external energy and 
%        corresponding forces.
%
%    See also HamiltonianKS, PeriodTable, ESDFInputParam.

%  Copyright (c) 2022-2023 Hengzhun Chen and Yingzhou Li, 
%                          Fudan University
%  This file is distributed under the terms of the MIT License.


ptable = HamKS.ptable;
dim = dimDef();
ntotFine = HamKS.domain.NumGridTotalFine();
numAtom = length(HamKS.atomList);
vol = HamKS.domain.Volume();

% clear HamKS.pseudoList
HamKS.pseudoList = struct(...
        'pseudoCharge', [], ...
        'vLocalSR', [], ...
        'vnlList', [] ...
        );

gridpos = UniformMeshFine(HamKS.domain);


% ---------------------- number of occupied states ---------------------
% calculate the number of occupied states
% need to distinguish the number of charges carried by the ion and that
% carried by the electron
nZval = 0;
for i = 1 : numAtom
    atype = HamKS.atomList(i).type;
    if ~ptable.pteMap.isKey(atype)
        error('Cannot find the atom type.');
    end
    nZval = nZval + ptable.Zval(atype);
end
% add extra electron
nelec = nZval + HamKS.numExtraElectron;

% This is spin-restricted calculation. nelec should be even.
% If this is a PWDFT calculation, it will be error.
% If this is just a PW subproblem of DGDFT, it is allowable.
if mod(nelec, 2) ~= 0
    if ~HamKS.isDGDFT
        error("This is spin-restricted calculation. nelec should be even. ");
    else
        warning("This is spin-restricted calculation. nelec should be even. ");
    end
end
HamKS.numOccupiedState = ceil(nelec / HamKS.numSpin);


% ---------------------- local pseudopotential -------------------------
timeStart = tic;
InfoPrint(0, "Computing the local pseudopotential");

HamKS.pseudoCharge(:) = 0;
HamKS.vLocalSR(:) = 0;
for i = 1 : numAtom
    [HamKS.pseudoList(i).vLocalSR, HamKS.pseudoList(i).pseudoCharge] = ...
        ptable.CalculateVLocal(HamKS.atomList(i), HamKS.domain, gridpos);
    % accumulate to the global vector
    if ~isempty(HamKS.pseudoList(i).vLocalSR)
        % VLocal short range
        idx = HamKS.pseudoList(i).vLocalSR.idx;
        val = HamKS.pseudoList(i).vLocalSR.val;
        HamKS.vLocalSR(idx) = HamKS.vLocalSR(idx) + val;
        % pseudo charge
        idx = HamKS.pseudoList(i).pseudoCharge.idx;
        val = HamKS.pseudoList(i).pseudoCharge.val;
        HamKS.pseudoCharge(idx) = HamKS.pseudoCharge(idx) + val;            
    end
end

timeEnd = toc(timeStart);
InfoPrint(0, 'Time for local pseudopotential %8f [s]\n', timeEnd);

sumrho = sum(HamKS.pseudoCharge) * vol / ntotFine;
InfoPrint(0, "Sum of Pseudocharge                          = ", sumrho);
InfoPrint(0, "Number of Occupied States                    = ", HamKS.numOccupiedState);

% adjustment should be multiplicative
factor = nZval / sumrho;
HamKS.pseudoCharge = HamKS.pseudoCharge * factor;

InfoPrint(0, "After adjustment, Sum of Pseudocharge        = ", nZval);    


% ----------------------- nonlocal projectors ----------------------------
timeStart = tic;
InfoPrint(0, "Computing the non-local pseudo pseudopotential");

count = 0;  % the total number of PS used
for i = 1 : numAtom
    % introduce the nonlocal pseudopotential on the fine grid
    atom = HamKS.atomList(i);
    if ptable.IsNonlocal(atom.type)
        vnlList = ptable.CalculateNonlocalPP(atom, HamKS.domain, gridpos);
        HamKS.pseudoList(i).vnlList = vnlList;
        count = count + length(vnlList.wgt);
    end
end

InfoPrint(0, "Total number of nonlocal pseudopotential = ",  count);
timeEnd = toc(timeStart);
InfoPrint(0, 'Time for nonlocal pseudopotential %8f [s]\n', timeEnd);


% ------------------- some other energies and forces -------------------

[HamKS.Eself, HamKS.EIonSR, HamKS.forceIonSR] = ...
    CalculateIonSelfEnergyAndForce(ptable, HamKS.atomList, HamKS.domain);

[HamKS.EVdw, HamKS.forceVdw] = CalculateVdwEnergyAndForce(...
            HamKS.domain, HamKS.atomList, HamKS.VDWType, HamKS.XCType);

HamKS.Eext = 0;

HamKS.forceExt = zeros(length(HamKS.atomList), dim);

end