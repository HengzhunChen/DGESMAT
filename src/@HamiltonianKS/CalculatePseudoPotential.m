function HamKS = CalculatePseudoPotential(HamKS)
% HAMILTONIANKS/CALCULATEPSEUDOPOTENTIAL calculates pseudo potential.
%
%    HamKS = CalculatePseudoPotential(HamKS) computes 
%    (1) pseudo potential for each atom in HamKS.atomList and stores as a
%        struct list HamKS.pseudoList whose member include pseudoCharge, 
%        vLocalSR and vnlList;
%    (2) number of occupied states and stores as HamKS.numOccupiedState;
%    (3) local potential generated by all atoms. 
%        If user option isUseVLocal is true, computes short range local 
%        potential and Gaussian compensation charge, stores as 
%        HamKS.vLocalSR and HamKS.pseudoCharge respectively.
%        If user option isUseVLocal is false, computes pseudoCharge and
%        save as HamKS.pseudoCharge;
%    (4) other energies and forces, including self energy, (short range 
%        ionic energy if isUseVLocal), van der Waals energy and external 
%        energy and corresponding forces.
%
%    See also HamiltonianKS, PeriodTable, ESDFInputParam.

%  Copyright (c) 2022-2023 Hengzhun Chen and Yingzhou Li, 
%                          Fudan University
%  This file is distributed under the terms of the MIT License.


ptable = HamKS.ptable;
dim = dimDef();
ntotFine = HamKS.domain.NumGridTotalFine();
numAtom = length(HamKS.atomList);
vol = HamKS.domain.Volume();

% clear HamKS.pseudoList
HamKS.pseudoList = struct(...
        'pseudoCharge', [], ...
        'vLocalSR', [], ...
        'vnlList', [] ...
        );

gridpos = UniformMeshFine(HamKS.domain);


% ---------------------- number of occupied states ---------------------
% calculate the number of occupied states
% need to distinguish the number of charges carried by the ion and that
% carried by the electron
nZion = 0;
for i = 1 : numAtom
    atype = HamKS.atomList(i).type;
    if ~ptable.pteMap.isKey(atype)
        error('Cannot find the atom type.');
    end
    nZion = nZion + ptable.Zion(atype);
end
% add extra electron
nelec = nZion + HamKS.numExtraElectron;

% This is spin-restricted calculation. nelec should be even.
% If this is a PWDFT calculation, it will be error.
% If this is just a PW subproblem of DGDFT, it is allowable.
if mod(nelec, 2) ~= 0
    if ~isDGDFT
        error("This is spin-restricted calculation. nelec should be even. ");
    else
        warning("This is spin-restricted calculation. nelec should be even. ");
    end
end
HamKS.numOccupiedState = ceil(nelec / HamKS.numSpin);


% ---------------------- local pseudopotential -------------------------
timeStart = tic;
InfoPrint(0, "Computing the local pseudopotential");

if ~HamKS.userOption.isUseVLocal
    % compute pseudocharge by Pseudo Charge formulation
    HamKS.pseudoCharge(:) = 0;
    for i = 1 : numAtom
        HamKS.pseudoList(i).pseudoCharge = ...
            ptable.CalculatePseudoCharge(HamKS.atomList(i), HamKS.domain, gridpos);

        % accumulate to global vector
        if ~isempty(HamKS.pseudoList(i).pseudoCharge.idx)
            idx = HamKS.pseudoList(i).pseudoCharge.idx;
            val = HamKS.pseudoList(i).pseudoCharge.val;
            HamKS.pseudoCharge(idx) = HamKS.pseudoCharge(idx) + val; 
            % 1 means VALUE of pseudocharge            
        end
    end    
    timeEnd = toc(timeStart);
    InfoPrint(0, 'Time for local pseudopotential %8f [s] \n', timeEnd);

    sumrho = sum(HamKS.pseudoCharge) * vol / ntotFine;
    InfoPrint(0, "Sum of Pseudocharge                          = ", sumrho);
    InfoPrint(0, "Number of Occupied States                    = ", HamKS.numOccupiedState);
    
    % adjustment should be multiplicative
    factor = nZion / sumrho;
    HamKS.pseudoCharge = HamKS.pseudoCharge * factor;    
    
    InfoPrint(0, "After adjustment, Sum of Pseudocharge        = ", nZion);
    
else 
    % compute VLocal by Vlocal formulation
    HamKS.pseudoCharge(:) = 0;
    HamKS.vLocalSR(:) = 0;
    for i = 1 : numAtom
        [HamKS.pseudoList(i).vLocalSR, HamKS.pseudoList(i).pseudoCharge] = ...
            ptable.CalculateVLocal(HamKS.atomList(i), HamKS.domain, gridpos);
        % accumulate to the global vector
        if ~isempty(HamKS.pseudoList(i).vLocalSR)
            % VLocal short range
            idx = HamKS.pseudoList(i).vLocalSR.idx;
            val = HamKS.pseudoList(i).vLocalSR.val;
            HamKS.vLocalSR(idx) = HamKS.vLocalSR(idx) + val;
            % pseudo charge
            idx = HamKS.pseudoList(i).pseudoCharge.idx;
            val = HamKS.pseudoList(i).pseudoCharge.val;
            HamKS.pseudoCharge(idx) = HamKS.pseudoCharge(idx) + val;            
        end
    end
    
    timeEnd = toc(timeStart);
    InfoPrint(0, 'Time for local pseudopotential %8f [s]\n', timeEnd);

    sumrho = sum(HamKS.pseudoCharge) * vol / ntotFine;
    InfoPrint(0, "Sum of Pseudocharge                          = ", sumrho);
    InfoPrint(0, "Number of Occupied States                    = ", HamKS.numOccupiedState);
    
    % adjustment should be multiplicative
    factor = nZion / sumrho;
    HamKS.pseudoCharge = HamKS.pseudoCharge * factor;
    
    InfoPrint(0, "After adjustment, Sum of Pseudocharge        = ", nZion);    
end


% ----------------------- nonlocal projectors ----------------------------
timeStart = tic;
InfoPrint(0, "Computing the non-local pseudo pseudopotential");

count = 0;  % the total number of PS used
for i = 1 : numAtom
    % introduce the nonlocal pseudopotential on the fine grid
    atom = HamKS.atomList(i);
    if ptable.IsNonlocal(atom.type)
        vnlList = ptable.CalculateNonlocalPP(atom, HamKS.domain, gridpos);
        HamKS.pseudoList(i).vnlList = vnlList;
        count = count + length(vnlList.wgt);
    end
end

InfoPrint(0, "Total number of nonlocal pseudopotential = ",  count);
timeEnd = toc(timeStart);
InfoPrint(0, 'Time for nonlocal pseudopotential %8f [s]\n', timeEnd);


% ------------------- some other energies and forces -------------------

[HamKS.Eself, HamKS.EIonSR, HamKS.forceIonSR] = ...
                        CalculateIonSelfEnergyAndForce(HamKS, ptable);

[HamKS.EVdw, HamKS.forceVdw] = CalculateVdwEnergyAndForce(HamKS);

HamKS.Eext = 0;

HamKS.forceExt = zeros(length(HamKS.atomList), dim);

end