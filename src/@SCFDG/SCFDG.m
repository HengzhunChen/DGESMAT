classdef SCFDG
    % SCFDG Self consistent iteration using the DG method    
    %
    %    scfDG = SCFDG() returns an empty SCFDG object.
    %
    %    scfDG = SCFDG(hamDG, vecEigSol, ptable) returns a SCFDG object 
    %    with respect to HamiltonianDG object hamDG, a cell vecEigSol 
    %    containing EigenSolverKS object over each extended element and 
    %    a PeriodTable object ptable.
    %
    %    See also HamiltonianDG, EigenSolverKS, PeriodTable, ESDFInputParam.

    %  Copyright (c) 2022 Hengzhun Chen and Yingzhou Li, 
    %                     Fudan University
    %  This file is distributed under the terms of the MIT License.

    properties (SetAccess = private)
        domain
        numElem
        extElemRatio
        numUnusedState
        XCType
        VDWType        

        ptable
        hamDG
        vecEigSol 
        fft
        
        controlVar
        PWSolver
        DGSolver
        
        scfTotalInnerIter
        scfNorm
        scfInnerNorm
        scfOuterNorm
        efreeDifPerAtom 

        ecutWavefunction
        densityGridFactor
        LGLGridFactor
        PeriodicUniformToLGLMat
        PeriodicUniformFineToLGLMat
        PeriodicGridExtElemToGridElemMat        
        
        Tbeta
        Tsigma
        vtotLGLSave
        EfreeHarris
        EfreeSecondOrder
        Efree
        Etot
        Ekin
        Ehart
        Ecor
        Exc
        Evdw
        EVxc
        Eself
        fermi
        forceVdw
        
        periodicPotential
        potentialBarrier
        restart
        smearing
        mix                
        
        CheFSIPW
        CheFSIDG
        
        ionDyn
    end
    
    methods (Access = public)
        function scfDG = SCFDG(varargin)
            scfDG.controlVar = struct(...
                'eigMinTolerance', [], ...
                'eigTolerance', [], ...
                'eigMinIter', [], ...
                'eigMaxIter', [], ...
                'scfInnerTolerance', [], ...
                'scfInnerMinIter', [], ...
                'scfInnerMaxIter', [], ...
                'scfOuterEnergyTolerance', [], ...
                'scfOuterTolerance', [], ...
                'scfOuterMinIter', [], ...
                'scfOuterMaxIter', [], ...
                'SVDBasisTolerance', [], ...
                ...
                'isPWeigToleranceDynamic', [] ...
                ...
                );
            
            scfDG.mix = struct(...
                'mixMaxDim', [], ...
                'mixType', [], ...
                'mixStepLength', [], ...
                'mixVariable', [], ...
                'mixOuterSave', [], ...
                'mixInnerSave', [], ...
                'dfOuterMat', [], ...
                'dvOuterMat', [], ...
                'dfInnerMat', [], ...
                'dvInnerMat', [] ...
                );
            
            scfDG.potentialBarrier = struct(...
                'BarrierW', [], ...
                'BarrierS', [], ...
                'BarrierR', [], ...
                'vBarrier', [] ...
                );
            
            scfDG.periodicPotential = struct(...
                'distancePeriodize', [], ...
                'vBubble', [] ...
                );                
            
            scfDG.restart = struct(...
                'DensityFileName', "", ...
                'WfnExtElemFileName', "" ...
                );
                        
            scfDG.smearing = struct(...
                'SmearingScheme', "", ...
                'MPsmearingOrder', [] ...
                );
            
            scfDG.CheFSIPW = struct(...
                'firstFilterOrder', [], ...
                'firstCycleNum', [], ...
                'generalFilterOrder', [], ...
                'isApplyWfnEcut', [] ...
                );
            
            scfDG.CheFSIDG = struct(...
                'firstFilterOrder', [], ...
                'firstCycleNum', [], ...
                'secondOuterIter', [], ...
                'secondFilterOrder', [], ...
                'secondCycleNum', [], ...
                'generalFilterOrder', [], ...
                'generalCycleNum', [], ...
                ...
                'isUseCompSubspace', [], ...
                'CompSubspace', [] ...
                );
            
            scfDG.CheFSIDG.Compsubspace = struct(...
                'nStates', [], ...
                'ionIterRegularChebyFreq', [], ...
                'biggerGridDimFac', [], ...
                'lobpcgIter', [], ...
                'lobpcgTol', [], ...
                'isHMatTopStatesUseCheby', [], ...
                'HMatFilterOrder', [], ...
                'HMatCycleNum', [], ...
                'HMatdeltaFudge', [], ...
                'nSolve', [], ...
                'saved_a_L', [], ...
                'traceHMat', [], ...
                'topEigvals', [], ...
                'topOccupations', [], ...
                'startGuess', [], ...
                'matC', [], ...
                'innerLowerBound', [], ...
                'innerUpperBound', [], ...
                'inner_a_L', [] ...
                );

            
            scfDG.ionDyn = struct(...
                'isChebyInIonDyn', [], ...
                'ionDynIter', [], ...
                'isUseEnergySCFconvergence', [], ...
                'MDscfEtotDiffTol', [], ...
                'MDscfEbandDiffTol', [], ...
                'MDscfEtot', [], ...
                'MDscfEtotOld', [], ...
                'MDscfEtotFiff', [], ...
                'MDscfEband', [], ...
                'MDscfEbandOld', [], ...
                'MDscfEbandDiff', [] ...
                );
            
               
            switch (nargin)
                case 0 
                    scfDG.domain = Domain();
                    return;
                case 3
                    hamDG = varargin{1};
                    vecEigSol = varargin{2};
                    ptable = varargin{3};
                    
                    fft = hamDG.fft;    
                    scfDG = Setup(scfDG, hamDG, vecEigSol, fft, ptable);
                otherwise
                    error('Wrong number of arguments');
            end
        end
        
        function rhoLGL = InterpPeriodicUniformFineToLGL(scfDG, rhoUniform)
            % transform data over uniform fine grid to LGL grid.
            eigSol = scfDG.vecEigSol{1, 1, 1};
            numGridExtElemFine = eigSol.fft.domain.numGridFine;
            numLGLGrid = scfDG.hamDG.grid.numLGLGridElem;            
            
            rhoLGL = InterpPeriodicUniformFineToLGL(...
                scfDG.PeriodicUniformFineToLGLMat, ...
                numGridExtElemFine, ...
                numLGLGrid, ...
                rhoUniform);
        end
        
        function psiLGL = InterpPeriodicUniformToLGL(scfDG, psiUniform)
            % transform data over uniform grid to LGL grid.
            eigSol = scfDG.vecEigSol{1, 1, 1};
            numGridExtElem = eigSol.fft.domain.numGrid;
            numLGLGrid = scfDG.hamDG.grid.numLGLGridElem;
            
            psiLGL = InterpPeriodicUniformToLGL(...
                scfDG.PeriodicUniformToLGLMat, ...
                numGridExtElem, ...
                numLGLGrid, ...
                psiUniform);
        end

    end
end